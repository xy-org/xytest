import libxy.cli;
import libxy.(string, stdio, fs, list, memory, error, process, perf, tty);


;; Collect, Compile, and Run Tests
struct Args {
    ;; Where to look for tests
    dir : Str~MemManaged;

    ;; Run tests only form this module
    module: Str~MemManaged;
}

func parse(:Args) -> Args {
    args: Args;

    schema: CliSchema;
    schema'prog("xytest", short="Discover and Run Tests");
    schema'param("dir", .positional);
    schema'param(
        "module", short=`m`,
        desc="Compile and run tests only from modules matching given name",
    );

    parsed := schema'parse();
    for (arg in parsed) {
        if (arg.name == "dir") {
            args.dir = arg.value'copy;
        } elif (arg.name == "module") {
            args.module = arg.value'copy;
        }
    }
    return args;
}

;; Use this struct to mark test function
*struct Test~[xyTag:=TagCtor{label="test"}] {}

;; Entry point for the test discovery stage
func main~EntryPoint(args := Args'parse) -> void | Int {
    moduleDirs : mut = List~[Str~MemManaged]{};
    findModules(moduleDirs, args.dir, args.dir);
    filterModules(moduleDirs, args.module);
    print(f"Found {moduleDirs'len} xy modules\n");

    mkdir(".xytest_cache");
    runnerFile : mut = open(".xytest_cache/xytestRunner.xy", OpenFlags{.create, .writeOnly, .truncate});
    for (dir in moduleDirs) {
        runnerFile'write(f"import {dir};\n");
    }

    runnerFile'write("{#! cat xytestRunner.src }");
    runnerFile'close;
    runnerFile = File{-1};

    print("Building test runner executable...\n");
    xycArgs := List~Str~MemStatic @ {
        ".xytest_cache/xytestRunner.xy", "-L", "..", "-L", "deps/",
        "-o", "bin/run-tests",
    };
    compilationStatus := run("xyc", xycArgs)'wait();
    if (compilationStatus != 0) {
        print(f"Compilation failed with {compilationStatus}\n");
        error compilationStatus;
    }

    print("Running tests...\n");
    runArgs : List~Str~MemManaged;
    error run("bin/run-tests",runArgs)'wait();
}

func findModules(foundDirs: mut List~Str~MemManaged, dir: Str~MemManaged, moduleName: Str) {
    print(f"Looking for tests in {dir}\n");

    isModule : Bool;
    for (node in ls(dir, .type)) {
        if (node.type.dir) {
            subdir := path"{dir}/{node.name}";
            submodule := (
                if (moduleName.size > 0) f"{moduleName}.{node.name}"
                else f"{node.name}"
            );
            findModules(foundDirs, subdir, submodule);
        } elif (!isModule && node.type.file && node.name'endswith(".xy")) {
            .isModule;
            print(f"Found xy module in {dir} {moduleName}\n");
            d : mut = moduleName'copy;
            foundDirs'append(d =>);
        }
    }
}

func filterModules(modules: mut List~Str~MemManaged, filter: Str) {
    if (filter.size <= 0) return;

    matching: %modules;
    for (module in modules) {
        if (module'find(filter) >= 0) {
            matching'append(module =>);
        }
    }
    modules =< matching;
}

*struct TestVector {
    name: Str~MemStatic;
    package: Str~MemStatic;
    testCb: ()->();
}

*func runTests(tests: List~TestVector) -> void | Int {
    testingStart := time();

    print(f"Found {tests'len} tests\n");
    for (t in tests) {
        print(f"Running {t.package}.{t.name}... ");
        [t.testCb]();
        print("Success\n");
    }

    elapsed := time() - testingStart;
    elapsedS := elapsed / 1_000_000_000l;
    elapsedDecis := (elapsed \rem 1_000_000_000l) / 100_000_000l;

    badge := badge(tests'len);
    print(
        f"{Esc{.bold, .fg.green}}\
        ===== {tests'len} passed in {elapsedS}.{elapsedDecis}s {badge}=====\
        {Esc{.reset}}\n"
    );
}

func badge(num: Usize) -> Str~MemStatic {
    if (num > 0 && num <= 2) return "ðŸ¥³ ";
    if (num == 42) return "ðŸ¤ª ";
    if (num == 69) return "â˜¯ï¸ ";
    if (num == 100) return "ðŸ’¯ ";
    if (num >= 300 && num < 310) return "ðŸ¡ ";
    if (num == 314) return "ðŸ¥§ ";
    if (num == 628) return "ðŸ¥§ðŸ¥§ ";
    if (num == 942) return "ðŸ¥§ðŸ¥§ðŸ¥§ ";
    if (num >= 1000 && num < 1010) return "ðŸ‰ ";
    if (num >= 2000 && num < 2010) return "ðŸ¦– ";
    if (num >= 10000 && num < 10010) return "ðŸ¦„ ";
    return "";
}
